# Задание


## Описание

Создать два REST метода: один для отправки данных, второй для их получения.

Для отправки используем протокол POST, для получения GET.

Методы называем в соответствии с конвенцией, без протокола в названии и с использованием тире. Пример: отправить данные по студенту - [POST] /our-best-student, получить данные - [GET] /our-best-student/123 <= ID.

1. Первый метод должен принимать данные и обрабатывать их в асинхронном режиме. Т.е. сразу отпускать клиента, сообщая ему только о том, что данные приняты. В это время полученные данные обрабатываются в фоне и сохраняются в базу данных. 


2. Под обработкой данных подразумевается вызов любого внешнего сервиса в неблокирующем режиме, получение ответа для его дальнейшего использования.


3. Студенту предлагается самому придумать какие данные он будет хранить, достаточно одной таблицы. Но для энтузиастов можно сделать более сложную структуру.


4. Надо сделать доменные сущности, объекты которые соответствуют структуре таблицы и DTO объекты, которые используются для передачи данных на сервер и для передачи данных пользователю. DTO объекты могут содержать не прямую проекцию таблиц, а только необходимые для конкретного метода поля.


5. Выполнить маппинг (преобразование) из объекта полученного от пользователя в объект базы данных для сохранения. И обратное действия для передачи данных пользователю.


6. Второй метод отдает запрошенные данные или отправляет DTO объект с текстом об ошибке.


Для энтузиастов, можно усложнять на тему корутин, используя разные подходы, которые были разобраны в лекции и не только)



## Рекомендации:



для организации асинхронной обработки используем:

```CoroutineScope(Dispatchers.Default).launch { // }```
для записи в базу и чтения из нее используем спец. диспетчер:

```withContext(Dispatchers.IO) { // }```


Для вызова стороннего сервиса в неблокирующем режиме используем Spring webClient, для сопряжения реактивного мира Java с миром корутин Kotlin используем расширения .awaitXXX, из файла WebClientExtensionsKt. Для webClient используем зависимости spring-webflux.