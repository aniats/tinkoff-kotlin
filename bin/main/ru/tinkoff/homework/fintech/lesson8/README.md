# 8.2 Задание по concurrency

## Описание
Написать реализацию простого пула потоков, для которого можно задать кол-во потоков.

После создания пула потоков, все потоки запускаются, и не обнаружив заданий в очереди, потоки переходят в режим ожидания.

Передавая задание на выполнение, мы его предварительно размещаем в очереди и сигнализируем любому потоку, что надо выйти из режима ожидания и проверить очередь.

Если в очереди есть задание, разбуженный поток забирает его себе на выполнение. Задание удаляется из очереди.

После выполнения задания поток проверяет очередь, и если там есть еще задание, то он его выполняет. Если заданий в очереди нет, то поток опять переходит в режим ожидания.

После выполнения всех заданий, пул потоков нужно остановить, т.е. остановить все потоки в нем. Если поток который мы хотим завершить спит, то его надо предварительно прервать.

## Реализация

1. Для нашего пула потоков мы имплементируем интерфейс java.util.concurrent.Executor и создаем класс ThreadPool.

2. Для хранения очереди заданий использовать - java.util.concurrent.LinkedBlockingQueue()

3. Экземпляры классов наших рабочих потоков можно хранить в обычном списке. Он хранится там для того чтобы их можно было остановить.

4. В конструкторе нашего пула потоков мы проверяем допустимость кол-ва потоков, создаем наши рабочие потоки, запускаем их и кладем в наш список.

5. Для наших рабочих потоков мы расширяем класс java.lang.Thread() и создаем класс WorkerThread:

    1. в нем есть только переопределенный метод - run()

    2. в этом методе у нас есть задача, которую мы берем из очереди, если очередь не пустая.

    3. если задача взята, ее надо исполнить.

    4. если очередь пустая, то поток переходит в режим ожидания, и ждет пока его разбудят (при помещения задания в очередь).

    5. если послана команда останова работы, то все задания выполняются до конца и поток завершается.

    6. все действия повторяются бесконечно.

6. В классе ThreadPool должно быть 2 метода:

    1. обязательный метод выполнения задач - execute(Runnable):

        1. в этом методе мы добавляем здание в очередь и уведомляем один из потоков нашего пула.

    2. и метод завершения работы пула потоков - shutdown():

        1. в котором мы ставим признак, что поток должен быть завершен, и прерываем потоки, если вдруг они находится в режиме ожидания.

7. Опционально! можно организовать проверку завершенности всех потоков в методе shutdown() и возвращать признак успешного или неуспешного завершения.

8. Создать экземпляр нашего пула потоков, передать ему задания на выполнение, остановить наш пул потоков.



# Рекомендации:

- Для перевода потока в режим ожидания используем метод obj.wait()


- Для уведомления потока, находящегося в режиме ожидания, используем метод obj.notify()


- Не забываем про особые условия, из которых вызываются методы wait()/notify()


- Для появления методов wait()/notify() в Kotlin, используем приведение типа к java.lang.Object


- Для прерывания потока, находящегося в режиме ожидания, используем метод thread.interrupt()


- Для обеспечения бесконечности исполнения используем конструкцию - while(true) { // }